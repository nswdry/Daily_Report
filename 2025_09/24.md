# 2025年9月24日(水)

# やったこと📝

- [プラクティス プログラムの修正（リバーシ編）（Reスキル） \| FBC](https://bootcamp.fjord.jp/practices/321)

# わかったこと💡

## 残りのエラーについて
:::details プログラムの修正
```ruby
F
Failure:ReversiMethodsTest#test_cannot_put_stone [test/reversi_methods_test.rb:73]:Expected true to not be truthy.

rails test test/reversi_methods_test.rb:61
F
Failure:ReversiMethodsTest#test_finished_of_full_board [test/reversi_methods_test.rb:107]:Expected false to be truthy.
```
今残っているエラーは残り２つです。両方とも置けないはずの場所で置けると判断されてしまっています。
原因として考えられるメソッドのうち、`turn`メソッドがなんとなく怪しそうな気がするので、そこを見てみました。
```ruby  
  def turn(board, target_pos, attack_stone_color, direction)
    return false if target_pos.out_of_board?
    return false if target_pos.stone_color(board) == attack_stone_color

    next_pos = target_pos.next_position(direction)
    if (next_pos.stone_color(board) == attack_stone_color) || turn(board, next_pos, attack_stone_color, direction)
      board[target_pos.row][target_pos.col] = attack_stone_color
      true
    else
      false
    end
  end
```
まず上記2行で条件分岐を行っています。盤上外の場合と、攻撃側の色と隣り合う石が全て同色だった場合はfalseを返して終了します。→この先はもう裏返せないという条件で処理を終了するための条件。
```ruby  
   return false if target_pos.out_of_board?
   return false if target_pos.stone_color(board) == attack_stone_color
```

- `binding.break`を設置して`ruby test/reversi_methods_test.rb`を実行します
- 現在の変数を確認します 
- `target_pos.row, target_pos.col, target_pos.stone_color(board), attack_stone_color, direction`などの中身を見ます
- ステップイン(step)/ステップオーバー(next)で次に進む
:::
## デバッグコマンド
|コマンド|使いどころ|
|---|---|
| step(ステップイン)| メソッドの中にも入る。関数の中身を確認したいときに使う|
| next(ステップオーバー)| 次の行まで進み、関数の内部には入らない| | step out(ステップアウト| 現在の関数の残りを実行して、呼び出し元に戻る|
 | continue| ブレークポイントで止まった場所から次の停止点まで一気に実行する| 

:::details デバッグ中…

```ruby
    63|   def turn(board, target_pos, attack_stone_color, direction)
    64|     binding.break
    65|     return false if target_pos.out_of_board?
=>  66|     return false if target_pos.stone_color(board) == BLANK_CELL
    67|     return false if target_pos.stone_color(board) == attack_stone_color
    68| 
    69|     next_pos = target_pos.next_position(direction)
    70|     if (next_pos.stone_color(board) == attack_stone_color) || turn(board, next_pos, attack_stone_color, direction)
=>#0    ReversiMethods#turn(board=[["W", "W", "W", "W", "W", "W", "W", "B"..., target_pos=#<Position:0x000000011c5e6718 @col=5, @ro..., attack_stone_color="W", direction=:top_left) at ~/Desktop/bug_reversi/lib/reversi_methods.rb:66
  #1    ReversiMethods#turn(board=[["W", "W", "W", "W", "W", "W", "W", "B"..., target_pos=#<Position:0x000000011c524b68 @col=6, @ro..., attack_stone_color="W", direction=:top_left) at ~/Desktop/bug_reversi/lib/reversi_methods.rb:70
  # and 30 frames (use `bt' command for all frames)
(ruby) target_pos.stone_color(board)
"B"
(ruby) attack_stone_color
"W"
(rdbg) direction
:top
```
:::
条件分岐時点で隣り合うセルが空白の場合はそのまま処理が進んでいってしまっていたので、そこを修正して再度テストを通してみました。

```ruby
# Running:

.........

Finished in 0.025977s, 346.4603 runs/s, 692.9207 assertions/s.

9 runs, 18 assertions, 0 failures, 0 errors, 0 skips
```

 とりあえず全てエラーが消えましたね！！
# 次にやること✅

- [プラクティス プログラムの修正（リバーシ編）（Reスキル） \| FBC](https://bootcamp.fjord.jp/practices/321)

# いまの気持ち🫶

上記のデバッグの基本を学び直して、ようやくどこに飛んでいくのか理解できました。急に意味不明なところに飛んでいくので全然操作がわからなくて困惑した覚えがあります。

とりあえず一旦エラーが消えてくれたので明日はまとめて提出したいと思います！長い時間がかかりましたが、なんとかエラーが消えてくれました。修正方法が合っているかどうかの自信はないですが、とりあえず一旦終わってくれたのが嬉しいです◎

# 学習時間

- 2時間30分(合計: 556時間15分)
